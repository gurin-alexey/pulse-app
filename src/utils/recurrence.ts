import { RRule, rrulestr } from 'rrule'
import type { Task } from '@/types/database'

/**
 * Parses a combined RRule/RRuleSet string (which may include RRULE and EXDATE lines)
 * generated by this utility, and returns a rule instance that respects exclusions.
 */
const getRuleInstance = (recurrenceRule: string, dtstart: Date) => {
    let finalRule = recurrenceRule
    if (!finalRule.includes('RRULE:') && !finalRule.includes('DTSTART:')) {
        finalRule = `RRULE:${finalRule}`
    }

    if (!finalRule.includes('DTSTART:')) {
        const dateStr = dtstart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
        finalRule = `DTSTART:${dateStr}\n${finalRule}`
    }

    return rrulestr(finalRule, { forceset: true })
}

export const generateRecurringInstances = (task: Task, rangeStart: Date, rangeEnd: Date) => {
    if (!task.recurrence_rule || !task.due_date) {
        return [task]
    }

    try {
        const dtstart = task.start_time ? new Date(task.start_time) : new Date(task.due_date + 'T00:00:00')
        const rule = getRuleInstance(task.recurrence_rule, dtstart)

        const dates = rule.between(rangeStart, rangeEnd, true)

        return dates.map((date) => {
            let endTimeString = null
            if (task.start_time && task.end_time) {
                const start = new Date(task.start_time)
                const end = new Date(task.end_time)
                const duration = end.getTime() - start.getTime()
                const newEnd = new Date(date.getTime() + duration)
                endTimeString = newEnd.toISOString()
            }

            const instanceDueStr = [
                date.getFullYear(),
                String(date.getMonth() + 1).padStart(2, '0'),
                String(date.getDate()).padStart(2, '0')
            ].join('-')

            return {
                ...task,
                id: `${task.id}_recur_${date.getTime()}`,
                original_id: task.id,
                due_date: instanceDueStr,
                start_time: task.start_time ? date.toISOString() : null,
                end_time: endTimeString,
                is_virtual: true,
                occurrence_date: date.toISOString()
            }
        })

    } catch (e) {
        console.error('Failed to parse recurrence rule for task', task.id, e)
        return [task]
    }
}

/**
 * Adds an EXDATE to the recurrence rule string.
 */
export const addExDateToRRule = (currentRule: string, dateToExclude: Date) => {
    const iso = dateToExclude.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const exLine = `EXDATE:${iso}`

    let baseRule = currentRule
    if (!baseRule.includes('RRULE:')) {
        baseRule = `RRULE:${baseRule}`
    }

    return `${baseRule}\n${exLine}`
}

/**
 * Adds an UNTIL date to the recurrence rule string.
 */
export const addUntilToRRule = (currentRule: string, untilDate: Date) => {
    // UNTIL must be in UTC iCal format
    const iso = untilDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'

    let baseRule = currentRule
    if (!baseRule.includes('RRULE:')) {
        baseRule = `RRULE:${baseRule}`
    }

    // Replace or add UNTIL
    if (baseRule.includes('UNTIL=')) {
        return baseRule.replace(/UNTIL=[^; \n]+/, `UNTIL=${iso}`)
    } else {
        return baseRule + `;UNTIL=${iso}`
    }
}

/**
 * Updates DTSTART in an iCal-like string.
 */
export const updateDTStartInRRule = (currentRule: string, newDtStart: Date) => {
    const iso = newDtStart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const dtLine = `DTSTART:${iso}`

    if (currentRule.includes('DTSTART:')) {
        return currentRule.replace(/DTSTART:[^ \n]+/, dtLine)
    } else {
        return `${dtLine}\n${currentRule}`
    }
}
