import { RRule, rrulestr } from 'rrule'
import type { Task } from '@/types/database'

/**
 * Parses a combined RRule/RRuleSet string (which may include RRULE and EXDATE lines)
 * generated by this utility, and returns a rule instance that respects exclusions.
 */
const getRuleInstance = (recurrenceRule: string, dtstart: Date, isAllDay = false) => {
    let finalRule = recurrenceRule

    // Strip existing DTSTART lines to ensure we always use the current task date
    // This prevents "snapping back" when moving a task, as the rule would otherwise keep the old start date
    finalRule = finalRule.split('\n').filter(line => !line.startsWith('DTSTART')).join('\n')

    if (!finalRule.includes('RRULE:')) {
        finalRule = `RRULE:${finalRule}`
    }

    if (!finalRule.includes('DTSTART:')) {
        if (isAllDay) {
            const dateStr = [
                dtstart.getFullYear(),
                String(dtstart.getMonth() + 1).padStart(2, '0'),
                String(dtstart.getDate()).padStart(2, '0')
            ].join('') + 'T000000'
            finalRule = `DTSTART:${dateStr}\n${finalRule}`
        } else {
            const dateStr = dtstart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
            finalRule = `DTSTART:${dateStr}\n${finalRule}`
        }
    }

    return rrulestr(finalRule, { forceset: true })
}

export const generateRecurringInstances = (
    task: Task,
    rangeStart: Date,
    rangeEnd: Date,
    occurrencesMap?: Record<string, string> | Map<string, string>
) => {
    if (!task.recurrence_rule || !task.due_date) {
        return [task]
    }

    try {
        let dtstart: Date
        if (task.start_time) {
            dtstart = new Date(task.start_time)
        } else {
            const dateStr = (task.due_date || '').split('T')[0]
            dtstart = new Date(dateStr + 'T00:00:00')
        }

        if (isNaN(dtstart.getTime())) {
            console.warn('Invalid start date for recurrence', task.id, task.due_date)
            return [task]
        }

        const rule = getRuleInstance(task.recurrence_rule, dtstart, !task.start_time)

        const dates = rule.between(rangeStart, rangeEnd, true)

        const activeInstances: any[] = []

        dates.forEach((date) => {
            const instanceDueStr = [
                date.getFullYear(),
                String(date.getMonth() + 1).padStart(2, '0'),
                String(date.getDate()).padStart(2, '0')
            ].join('-')

            // Check if there is an exception for this specific date
            // Note: date from rrule includes time, we should probably key by date string for safety
            // Actually, DB stores date type, so we need to match date part.
            const lookupKey = `${task.id}_${instanceDueStr}`
            let status: string | undefined
            if (occurrencesMap instanceof Map) {
                status = occurrencesMap.get(lookupKey)
            } else {
                // Handle case where Map was serialized to Object in cache
                status = (occurrencesMap as any)?.[lookupKey]
            }

            if (status === 'skipped' || status === 'archived') {
                return // Skip this instance (don't render it)
            }

            let endTimeString = null
            if (task.start_time && task.end_time) {
                const start = new Date(task.start_time)
                const end = new Date(task.end_time)
                const duration = end.getTime() - start.getTime()
                const newEnd = new Date(date.getTime() + duration)
                endTimeString = newEnd.toISOString()
            }

            activeInstances.push({
                ...task,
                id: `${task.id}_recur_${date.getTime()}`,
                original_id: task.id,
                due_date: instanceDueStr,
                start_time: task.start_time ? date.toISOString() : null,
                end_time: endTimeString,
                is_virtual: true,
                is_completed: status === 'completed' ? true : task.is_completed, // Allow override
                occurrence_date: instanceDueStr // Store as YYYY-MM-DD for easy lookup later
            })
        })

        return activeInstances

    } catch (e) {
        console.error('Failed to parse recurrence rule for task', task.id, e)
        return [task]
    }
}

/**
 * Adds an EXDATE to the recurrence rule string.
 */
export const addExDateToRRule = (currentRule: string, dateToExclude: Date) => {
    const iso = dateToExclude.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const exLine = `EXDATE:${iso}`

    // If empty, just return the exdate (though unlikely useful on its own)
    if (!currentRule) return exLine

    return `${currentRule}\n${exLine}`
}

/**
 * Updates BYDAY in a weekly RRULE to match the provided date's weekday.
 */
export const updateRRuleByDay = (currentRule: string, newDate: Date) => {
    if (!currentRule) return currentRule

    const weekdayMap = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA']
    const newByDay = weekdayMap[newDate.getDay()]

    const lines = currentRule.split('\n')
    let updated = false

    const newLines = lines.map(line => {
        const isRuleLine = line.startsWith('RRULE:') || (!line.includes(':') && line.includes('FREQ='))
        if (!isRuleLine) return line

        let ruleContent = line.startsWith('RRULE:') ? line.substring(6) : line
        if (!ruleContent.includes('FREQ=WEEKLY')) return line

        if (ruleContent.includes('BYDAY=')) {
            ruleContent = ruleContent.replace(/BYDAY=[^;]+/, `BYDAY=${newByDay}`)
        } else {
            ruleContent = `${ruleContent};BYDAY=${newByDay}`
        }

        updated = true
        return line.startsWith('RRULE:') ? `RRULE:${ruleContent}` : ruleContent
    })

    return updated ? newLines.join('\n') : currentRule
}

/**
 * Adds or updates an UNTIL date in the recurrence rule string.
 */
export const addUntilToRRule = (currentRule: string, untilDate: Date) => {
    const iso = untilDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const lines = currentRule.split('\n')
    let ruleFound = false

    const newLines = lines.map(line => {
        if (line.startsWith('RRULE:') || (!line.includes(':') && line.includes('FREQ='))) {
            ruleFound = true
            let ruleContent = line
            if (ruleContent.startsWith('RRULE:')) {
                ruleContent = ruleContent.substring(6)
            }

            if (ruleContent.includes('UNTIL=')) {
                ruleContent = ruleContent.replace(/UNTIL=[^;]+/, `UNTIL=${iso}`)
            } else {
                ruleContent = `${ruleContent};UNTIL=${iso}`
            }

            return line.startsWith('RRULE:') ? `RRULE:${ruleContent}` : ruleContent
        }
        return line
    })

    if (!ruleFound && currentRule.includes('FREQ=')) {
        // Fallback: if single line without headers that wasn't caught above (unlikely given logic)
        // or if it was empty?
        if (currentRule.includes('UNTIL=')) {
            return currentRule.replace(/UNTIL=[^;]+/, `UNTIL=${iso}`)
        }
        return `${currentRule};UNTIL=${iso}`
    }

    return newLines.join('\n')
}

/**
 * Updates DTSTART in an iCal-like string.
 */
export const updateDTStartInRRule = (currentRule: string, newDtStart: Date) => {
    const iso = newDtStart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const dtLine = `DTSTART:${iso}`

    if (!currentRule) return dtLine

    const lines = currentRule.split('\n')
    const dtStartIndex = lines.findIndex(line => line.startsWith('DTSTART:'))

    if (dtStartIndex !== -1) {
        lines[dtStartIndex] = dtLine
        return lines.join('\n')
    } else {
        return `${dtLine}\n${currentRule}`
    }
}

/**
 * Returns a list of past dates (as YYYY-MM-DD strings) that should have had 
 * recurring instances but are not marked as completed/skipped/archived.
 * @param task The master task
 * @param occurrencesMap Map of existing performance records
 * @param referenceDate The date to check against (exclusive, usually "today")
 */
export const getPastIncompleteInstances = (
    task: Task,
    occurrencesMap: Record<string, string> | Map<string, string>,
    referenceDate: Date = new Date()
) => {
    if (!task.recurrence_rule || !task.due_date) return []

    try {
        let dtstart: Date
        if (task.start_time) {
            dtstart = new Date(task.start_time)
        } else {
            const dateStr = task.due_date.split('T')[0]
            dtstart = new Date(dateStr + 'T00:00:00')
        }

        if (isNaN(dtstart.getTime())) return []

        const rule = getRuleInstance(task.recurrence_rule, dtstart, !task.start_time)

        // We want all instances starting from the first one, up until (but NOT including) referenceDate
        // referenceDate is usually "Today 00:00:00" in local time to check past days.
        const endOfYesterday = new Date(referenceDate)
        endOfYesterday.setHours(0, 0, 0, 0)

        // between(after, before, inc)
        const dates = rule.between(dtstart, endOfYesterday, true)

        const incomplete: string[] = []

        dates.forEach(date => {
            const dateStr = [
                date.getFullYear(),
                String(date.getMonth() + 1).padStart(2, '0'),
                String(date.getDate()).padStart(2, '0')
            ].join('-')

            // If it's today or later, it's not a "past" instance for our logic
            const referenceDateStr = [
                endOfYesterday.getFullYear(),
                String(endOfYesterday.getMonth() + 1).padStart(2, '0'),
                String(endOfYesterday.getDate()).padStart(2, '0')
            ].join('-')

            if (dateStr >= referenceDateStr) return

            const lookupKey = `${task.id}_${dateStr}`
            let status: string | undefined
            if (occurrencesMap instanceof Map) {
                status = occurrencesMap.get(lookupKey)
            } else {
                status = (occurrencesMap as any)?.[lookupKey]
            }

            // If no status or status is 'pending' (though not usually stored), it's incomplete
            if (!status) {
                incomplete.push(dateStr)
            }
        })

        return incomplete
    } catch (e) {
        console.error('Failed to calculate past instances', e)
        return []
    }
}

/**
 * Returns the next occurrence date after the provided completion date.
 */
export const getNextOccurrenceDate = (task: Task, completionDate: Date) => {
    if (!task.recurrence_rule || !task.due_date) return null

    try {
        let dtstart: Date
        if (task.start_time) {
            dtstart = new Date(task.start_time)
        } else {
            const dateStr = task.due_date.split('T')[0]
            dtstart = new Date(dateStr + 'T00:00:00')
        }

        if (isNaN(dtstart.getTime())) return null

        const rule = getRuleInstance(task.recurrence_rule, dtstart, !task.start_time)
        return rule.after(completionDate, false)
    } catch (e) {
        console.error('Failed to get next occurrence', e)
        return null
    }
}

