import { RRule, RRuleSet, rrulestr } from 'rrule'
import type { Task } from '@/types/database'

/**
 * Parses a combined RRule/RRuleSet string (which may include RRULE and EXDATE lines)
 * generated by this utility, and returns a rule instance that respects exclusions.
 */
const getRuleInstance = (recurrenceRule: string, dtstart: Date) => {
    // If it's a simple string like "FREQ=DAILY", pack it into a full iCal string for rrulestr
    let finalRule = recurrenceRule
    if (!finalRule.includes('RRULE:') && !finalRule.includes('DTSTART:')) {
        finalRule = `RRULE:${finalRule}`
    }

    // Ensure we have a DTSTART in the string for rrulestr if it's missing
    if (!finalRule.includes('DTSTART:')) {
        const dateStr = dtstart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
        finalRule = `DTSTART:${dateStr}\n${finalRule}`
    }

    return rrulestr(finalRule, { forceset: true })
}

export const generateRecurringInstances = (task: Task, rangeStart: Date, rangeEnd: Date) => {
    if (!task.recurrence_rule || !task.due_date) {
        return [task]
    }

    try {
        const dtstart = task.start_time ? new Date(task.start_time) : new Date(task.due_date + 'T00:00:00')
        const rule = getRuleInstance(task.recurrence_rule, dtstart)

        // Get dates within range
        const dates = rule.between(rangeStart, rangeEnd, true)

        return dates.map((date) => {
            let endTimeString = null
            if (task.start_time && task.end_time) {
                const start = new Date(task.start_time)
                const end = new Date(task.end_time)
                const duration = end.getTime() - start.getTime()
                const newEnd = new Date(date.getTime() + duration)
                endTimeString = newEnd.toISOString()
            }

            const instanceDueStr = [
                date.getFullYear(),
                String(date.getMonth() + 1).padStart(2, '0'),
                String(date.getDate()).padStart(2, '0')
            ].join('-')

            return {
                ...task,
                id: `${task.id}_recur_${date.getTime()}`, // Virtual ID
                original_id: task.id, // Reference to master
                due_date: instanceDueStr,
                start_time: task.start_time ? date.toISOString() : null,
                end_time: endTimeString,
                is_virtual: true,
                occurrence_date: date.toISOString() // Store the specific occurrence date
            }
        })

    } catch (e) {
        console.error('Failed to parse recurrence rule for task', task.id, e)
        return [task]
    }
}

/**
 * Adds an EXDATE to the recurrence rule string.
 * This effectively "cuts" that instance from the sequence.
 */
export const addExDateToRRule = (currentRule: string, dateToExclude: Date) => {
    // Format date as iCal-style: YYYYMMDDTHHMMSSZ
    const iso = dateToExclude.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const exLine = `EXDATE:${iso}`

    // If the rule is a single line without RRULE prefix, add it
    let baseRule = currentRule
    if (!baseRule.includes('RRULE:')) {
        baseRule = `RRULE:${baseRule}`
    }

    return `${baseRule}\n${exLine}`
}
