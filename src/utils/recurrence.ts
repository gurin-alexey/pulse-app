import { RRule, rrulestr } from 'rrule'
import type { Task } from '@/types/database'

/**
 * Parses a combined RRule/RRuleSet string (which may include RRULE and EXDATE lines)
 * generated by this utility, and returns a rule instance that respects exclusions.
 */
const getRuleInstance = (recurrenceRule: string, dtstart: Date) => {
    let finalRule = recurrenceRule
    if (!finalRule.includes('RRULE:') && !finalRule.includes('DTSTART:')) {
        finalRule = `RRULE:${finalRule}`
    }

    if (!finalRule.includes('DTSTART:')) {
        const dateStr = dtstart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
        finalRule = `DTSTART:${dateStr}\n${finalRule}`
    }

    return rrulestr(finalRule, { forceset: true })
}

export const generateRecurringInstances = (task: Task, rangeStart: Date, rangeEnd: Date) => {
    if (!task.recurrence_rule || !task.due_date) {
        return [task]
    }

    try {
        const dtstart = task.start_time ? new Date(task.start_time) : new Date(task.due_date + 'T00:00:00')
        const rule = getRuleInstance(task.recurrence_rule, dtstart)

        const dates = rule.between(rangeStart, rangeEnd, true)

        return dates.map((date) => {
            let endTimeString = null
            if (task.start_time && task.end_time) {
                const start = new Date(task.start_time)
                const end = new Date(task.end_time)
                const duration = end.getTime() - start.getTime()
                const newEnd = new Date(date.getTime() + duration)
                endTimeString = newEnd.toISOString()
            }

            const instanceDueStr = [
                date.getFullYear(),
                String(date.getMonth() + 1).padStart(2, '0'),
                String(date.getDate()).padStart(2, '0')
            ].join('-')

            return {
                ...task,
                id: `${task.id}_recur_${date.getTime()}`,
                original_id: task.id,
                due_date: instanceDueStr,
                start_time: task.start_time ? date.toISOString() : null,
                end_time: endTimeString,
                is_virtual: true,
                occurrence_date: date.toISOString()
            }
        })

    } catch (e) {
        console.error('Failed to parse recurrence rule for task', task.id, e)
        return [task]
    }
}

/**
 * Adds an EXDATE to the recurrence rule string.
 */
export const addExDateToRRule = (currentRule: string, dateToExclude: Date) => {
    const iso = dateToExclude.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const exLine = `EXDATE:${iso}`

    // If empty, just return the exdate (though unlikely useful on its own)
    if (!currentRule) return exLine

    return `${currentRule}\n${exLine}`
}

/**
 * Adds or updates an UNTIL date in the recurrence rule string.
 */
export const addUntilToRRule = (currentRule: string, untilDate: Date) => {
    const iso = untilDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const lines = currentRule.split('\n')
    let ruleFound = false

    const newLines = lines.map(line => {
        if (line.startsWith('RRULE:') || (!line.includes(':') && line.includes('FREQ='))) {
            ruleFound = true
            let ruleContent = line
            if (ruleContent.startsWith('RRULE:')) {
                ruleContent = ruleContent.substring(6)
            }

            if (ruleContent.includes('UNTIL=')) {
                ruleContent = ruleContent.replace(/UNTIL=[^;]+/, `UNTIL=${iso}`)
            } else {
                ruleContent = `${ruleContent};UNTIL=${iso}`
            }

            return line.startsWith('RRULE:') ? `RRULE:${ruleContent}` : ruleContent
        }
        return line
    })

    if (!ruleFound && currentRule.includes('FREQ=')) {
        // Fallback: if single line without headers that wasn't caught above (unlikely given logic)
        // or if it was empty?
        if (currentRule.includes('UNTIL=')) {
            return currentRule.replace(/UNTIL=[^;]+/, `UNTIL=${iso}`)
        }
        return `${currentRule};UNTIL=${iso}`
    }

    return newLines.join('\n')
}

/**
 * Updates DTSTART in an iCal-like string.
 */
export const updateDTStartInRRule = (currentRule: string, newDtStart: Date) => {
    const iso = newDtStart.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z'
    const dtLine = `DTSTART:${iso}`

    if (!currentRule) return dtLine

    const lines = currentRule.split('\n')
    const dtStartIndex = lines.findIndex(line => line.startsWith('DTSTART:'))

    if (dtStartIndex !== -1) {
        lines[dtStartIndex] = dtLine
        return lines.join('\n')
    } else {
        return `${dtLine}\n${currentRule}`
    }
}

